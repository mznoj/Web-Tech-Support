<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browser and Network Diagnostic Tool for debugging access issues">
    <title>Browser & Network Diagnostic Tool v1.0.0</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
        }

        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
        }

        @media print {
            button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <noscript>
        <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; padding: 15px; margin: 20px; color: #721c24;">
            <strong>JavaScript Required:</strong> This diagnostic tool requires JavaScript to be enabled in your browser. Please enable JavaScript and reload the page.
        </div>
    </noscript>

    <div style="max-width: 1000px; margin: 20px;">
        <pre id="header" style="font-family: monospace; line-height: 1.5;"></pre>
        <div style="margin: 10px 0;">
            <button onclick="copyToClipboard()" id="copyBtn">Copy All Data</button>
            <button onclick="refreshData()">Refresh</button>
            <button onclick="exportAsJSON()">Export JSON</button>
            <button onclick="exportAsCSV()">Export CSV</button>
        </div>
        <pre id="diagnosticContent" style="font-family: monospace; line-height: 1.5;">Loading...</pre>
    </div>

    <script>
        // Version
        const TOOL_VERSION = '1.0.0';

        // Global data storage
        let diagnosticData = {};

        // Utility function to format values for plain text display
        function formatValue(value, type = 'default') {
            if (value === null || value === undefined) {
                return 'Not Available';
            }

            if (typeof value === 'boolean') {
                return value ? 'Enabled' : 'Disabled';
            }

            return value;
        }

        // Get browser information
        function getBrowserInfo() {
            try {
                const nav = navigator;
                const ua = nav.userAgent;

                // Parse browser name and version
                let browserName = 'Unknown';
                let browserVersion = 'Unknown';
                let mobileStatus = 'Unknown';

                // Modern: User-Agent Client Hints
                if (nav.userAgentData) {
                     // Filter out generic brands like "Not A(Brand" and "Chromium" to find the specific browser
                    const brands = nav.userAgentData.brands.filter(b => 
                        !b.brand.includes('Not A(Brand') && 
                        b.brand !== 'Chromium'
                    );
                    const brand = brands.length > 0 ? brands[0] : nav.userAgentData.brands[0];
                    
                    if (brand) {
                        browserName = brand.brand;
                        browserVersion = brand.version;
                    }
                    mobileStatus = nav.userAgentData.mobile ? 'Mobile' : 'Desktop';
                } 
                
                // Fallback: User Agent String
                if (browserName === 'Unknown') {
                    if (ua.indexOf('Firefox') > -1) {
                        browserName = 'Firefox';
                        browserVersion = ua.match(/Firefox\/([0-9.]+)/)?.[1] || 'Unknown';
                    } else if (ua.indexOf('Edg') > -1) {
                        browserName = 'Edge';
                        browserVersion = ua.match(/Edg\/([0-9.]+)/)?.[1] || 'Unknown';
                    } else if (ua.indexOf('Chrome') > -1) {
                        browserName = 'Chrome';
                        browserVersion = ua.match(/Chrome\/([0-9.]+)/)?.[1] || 'Unknown';
                    } else if (ua.indexOf('Safari') > -1) {
                        browserName = 'Safari';
                        browserVersion = ua.match(/Version\/([0-9.]+)/)?.[1] || 'Unknown';
                    }
                }

                return {
                    'User Agent': ua,
                    'Browser': `${browserName} ${browserVersion}`,
                    'Platform': nav.userAgentData?.platform || nav.platform || 'Unknown',
                    'Mobile': mobileStatus !== 'Unknown' ? mobileStatus : 'Not Detected',
                    'OS': getOSInfo(),
                    'Language': nav.language || 'Unknown',
                    'Languages': nav.languages?.join(', ') || 'Unknown',
                    'Cookies Enabled': nav.cookieEnabled,
                    'Hardware Concurrency': nav.hardwareConcurrency || 'Not Available',
                    'Device Memory': nav.deviceMemory ? `${nav.deviceMemory} GB` : 'Not Available',
                    'Max Touch Points': nav.maxTouchPoints || 0,
                    'Vendor': nav.vendor || 'Unknown'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get OS information from user agent
        function getOSInfo() {
            const ua = navigator.userAgent;
            if (ua.indexOf('Win') > -1) return 'Windows';
            if (ua.indexOf('Mac') > -1) return 'macOS';
            if (ua.indexOf('Linux') > -1) return 'Linux';
            if (ua.indexOf('Android') > -1) return 'Android';
            if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) return 'iOS';
            return 'Unknown';
        }

        // Get screen and display information
        function getScreenInfo() {
            try {
                return {
                    'Screen Resolution': `${screen.width} × ${screen.height}`,
                    'Available Screen': `${screen.availWidth} × ${screen.availHeight}`,
                    'Viewport Size': `${window.innerWidth} × ${window.innerHeight}`,
                    'Color Depth': `${screen.colorDepth}-bit`,
                    'Pixel Ratio': window.devicePixelRatio || 1,
                    'Orientation': screen.orientation?.type || window.orientation !== undefined ? `${window.orientation}°` : 'Not Available',
                    'Touch Support': navigator.maxTouchPoints > 0 || 'ontouchstart' in window
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get browser capabilities
        function getCapabilities() {
            try {
                const testLocalStorage = () => {
                    try {
                        localStorage.setItem('test', 'test');
                        localStorage.removeItem('test');
                        return true;
                    } catch (e) {
                        return false;
                    }
                };

                const testSessionStorage = () => {
                    try {
                        sessionStorage.setItem('test', 'test');
                        sessionStorage.removeItem('test');
                        return true;
                    } catch (e) {
                        return false;
                    }
                };

                return {
                    'JavaScript': true,
                    'Cookies': navigator.cookieEnabled,
                    'Local Storage': testLocalStorage(),
                    'Session Storage': testSessionStorage(),
                    'IndexedDB': 'indexedDB' in window,
                    'WebGL': (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                        } catch (e) {
                            return false;
                        }
                    })(),
                    'Service Worker': 'serviceWorker' in navigator,
                    'WebAssembly': typeof WebAssembly !== 'undefined',
                    'Geolocation': 'geolocation' in navigator,
                    'Notifications': 'Notification' in window,
                    'Web Workers': typeof Worker !== 'undefined',
                    'WebRTC': !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    'Canvas': (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(canvas.getContext && canvas.getContext('2d'));
                        } catch (e) {
                            return false;
                        }
                    })()
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get network information
        function getNetworkInfo() {
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

                return {
                    'Online Status': navigator.onLine ? 'Online' : 'Offline',
                    'Connection Type': conn?.effectiveType || 'Not Available',
                    'Downlink': conn?.downlink ? `${conn.downlink} Mbps` : 'Not Available',
                    'RTT': conn?.rtt ? `${conn.rtt} ms` : 'Not Available',
                    'Save Data': conn?.saveData !== undefined ? conn.saveData : 'Not Available',
                    'Protocol': window.location.protocol,
                    'Hostname': window.location.hostname,
                    'Port': window.location.port || 'Default'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get performance metrics
        function getPerformanceInfo() {
            try {
                // Modern Level 2 API
                const navEntry = performance.getEntriesByType?.("navigation")?.[0];
                const timing = performance.timing; // Fallback
                
                if (!navEntry && (!window.performance || !timing)) {
                     return { 'Performance API': 'Not Available' };
                }

                let pageLoadTime, dnsTime, tcpTime, tlsTime, ttfb, domLoad, navType, redirectCount;

                if (navEntry) {
                    pageLoadTime = navEntry.loadEventEnd - navEntry.startTime;
                    dnsTime = navEntry.domainLookupEnd - navEntry.domainLookupStart;
                    tcpTime = navEntry.connectEnd - navEntry.connectStart;
                    tlsTime = navEntry.secureConnectionStart > 0 ? navEntry.connectEnd - navEntry.secureConnectionStart : 'N/A (HTTP)';
                    ttfb = navEntry.responseStart - navEntry.startTime;
                    domLoad = navEntry.domContentLoadedEventEnd - navEntry.startTime;
                    navType = navEntry.type;
                    redirectCount = navEntry.redirectCount;
                } else {
                    // Fallback
                    const nav = performance.navigation;
                    pageLoadTime = timing.loadEventEnd - timing.navigationStart;
                    dnsTime = timing.domainLookupEnd - timing.domainLookupStart;
                    tcpTime = timing.connectEnd - timing.connectStart;
                    tlsTime = timing.secureConnectionStart > 0 ? timing.connectEnd - timing.secureConnectionStart : 'N/A (HTTP)';
                    ttfb = timing.responseStart - timing.navigationStart;
                    domLoad = timing.domContentLoadedEventEnd - timing.navigationStart;
                    navType = nav ? ['Navigate', 'Reload', 'Back/Forward'][nav.type] || 'Unknown' : 'Not Available';
                    redirectCount = nav?.redirectCount || 0;
                }

                return {
                    'Page Load Time': pageLoadTime > 0 ? `${Math.round(pageLoadTime)} ms` : 'Calculating...',
                    'DNS Lookup': dnsTime >= 0 ? `${Math.round(dnsTime)} ms` : 'Not Available',
                    'TCP Connection': tcpTime >= 0 ? `${Math.round(tcpTime)} ms` : 'Not Available',
                    'TLS Negotiation': typeof tlsTime === 'number' ? `${Math.round(tlsTime)} ms` : tlsTime,
                    'Time to First Byte': ttfb > 0 ? `${Math.round(ttfb)} ms` : 'Not Available',
                    'DOM Load': domLoad > 0 ? `${Math.round(domLoad)} ms` : 'Calculating...',
                    'Navigation Type': navType,
                    'Redirect Count': redirectCount
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get security context information
        function getSecurityInfo() {
            try {
                return {
                    'Protocol': window.location.protocol,
                    'Secure Context': window.isSecureContext,
                    'Cross-Origin Isolated': window.crossOriginIsolated || false,
                    'Referrer Policy': document.referrerPolicy || 'Not Set',
                    'Document Domain': document.domain,
                    'Mixed Content': window.location.protocol === 'https:' && document.querySelector('script[src^="http:"], img[src^="http:"], link[href^="http:"]') ? 'Detected' : 'None'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get additional details
        function getAdditionalDetails() {
            try {
                return {
                    'Diagnostic Tool Version': TOOL_VERSION,
                    'Current URL': window.location.href,
                    'Referrer': document.referrer || 'Direct/No Referrer',
                    'Document Mode': document.compatMode,
                    'Character Encoding': document.characterSet || document.charset,
                    'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                    'Timezone Offset': `UTC${new Date().getTimezoneOffset() > 0 ? '-' : '+'}${Math.abs(new Date().getTimezoneOffset() / 60)}`,
                    'Screen Orientation API': screen.orientation ? 'Supported' : 'Not Supported',
                    'Battery API': 'getBattery' in navigator ? 'Supported' : 'Not Supported'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get IP address from external API with fallback
        async function getIPAddress() {
            // Primary: ipify
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3s timeout for primary
                const response = await fetch('https://api.ipify.org?format=json', { 
                    signal: controller.signal 
                });
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    return data.ip;
                }
            } catch (error) {
                // Ignore error and try fallback
            }

            // Fallback: Cloudflare Trace (highly reliable)
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                const response = await fetch('https://1.1.1.1/cdn-cgi/trace', {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (response.ok) {
                    const text = await response.text();
                    const ipMatch = text.match(/^ip=(.+)$/m);
                    if (ipMatch) {
                        return ipMatch[1];
                    }
                }
            } catch (error) {
                // Fallback failed too
            }

            return 'Unable to fetch (blocked or offline)';
        }

        // Get DNS resolver connectivity information
        async function getDNSResolverInfo() {
            const resolvers = [
                { name: '1.1.1.1 (IPv4)', url: 'https://1.1.1.1/cdn-cgi/trace' },
                { name: '1.0.0.1 (IPv4)', url: 'https://1.0.0.1/cdn-cgi/trace' },
                { name: '2606:4700:4700::1111 (IPv6)', url: 'https://[2606:4700:4700::1111]/cdn-cgi/trace' },
                { name: '2606:4700:4700::1001 (IPv6)', url: 'https://[2606:4700:4700::1001]/cdn-cgi/trace' }
            ];

            const results = {};
            const promises = resolvers.map(async (resolver) => {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    const response = await fetch(resolver.url, { signal: controller.signal });
                    clearTimeout(timeoutId);

                    if (response.ok) {
                        results[resolver.name] = 'Connected';
                        return response.text();
                    } else {
                        results[resolver.name] = `Error ${response.status}`;
                        return null;
                    }
                } catch (error) {
                    results[resolver.name] = error.name === 'AbortError' ? 'Timeout' : 'Not Connected';
                    return null;
                }
            });

            const traces = await Promise.all(promises);
            return { results, traceData: traces.find(t => t !== null) };
        }

        // Parse Cloudflare trace data
        function parseCloudflareTrace(traceText) {
            if (!traceText) return {};

            const data = {};
            traceText.split('\n').forEach(line => {
                const [key, value] = line.split('=');
                if (key && value) data[key.trim()] = value.trim();
            });

            return {
                'Data Center Location': data.colo || 'Unknown',
                'TLS Version': data.tls || 'Unknown',
                'HTTP Version': data.http || 'Unknown',
                'WARP Status': data.warp === 'on' ? 'Active' : 'Not Active',
                'Gateway Status': data.gateway === 'on' ? 'Active' : 'Not Active'
            };
        }

        // Detect DNS encryption status
        function detectDNSEncryption(traceText, connectivityResults) {
            const trace = {};
            if (traceText) {
                traceText.split('\n').forEach(line => {
                    const [key, value] = line.split('=');
                    if (key && value) trace[key.trim()] = value.trim();
                });
            }

            const warpActive = trace.warp === 'on';
            const gatewayActive = trace.gateway === 'on';
            const cloudflareConnected = connectivityResults['1.1.1.1 (IPv4)'] === 'Connected';

            let dohStatus = 'Unknown';
            if (warpActive) {
                dohStatus = 'Using DNS-over-WARP';
            } else if (gatewayActive) {
                dohStatus = 'Using Cloudflare Gateway';
            } else if (cloudflareConnected) {
                dohStatus = 'Likely Using DoH (inferred)';
            } else {
                dohStatus = 'Not Detected';
            }

            return {
                'DNS-over-HTTPS (DoH)': dohStatus,
                'DNS-over-TLS (DoT)': 'Not Detectable in Browser',
                'DNS-over-WARP': warpActive ? 'Active' : 'Not Active'
            };
        }

        // Test DNS performance using DoH (updated with DNSSEC check)
        async function testDNSPerformance() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const startTime = performance.now();

                const response = await fetch(
                    'https://cloudflare-dns.com/dns-query?name=cloudflare.com&type=A&do=1',
                    {
                        headers: { 'Accept': 'application/dns-json' },
                        signal: controller.signal
                    }
                );

                clearTimeout(timeoutId);
                const endTime = performance.now();
                const queryTime = Math.round(endTime - startTime);

                if (response.ok) {
                    const data = await response.json();
                    return {
                        'DoH Query Time': `${queryTime} ms`,
                        'DoH Status': data.Status === 0 ? 'Working' : `Error (Status ${data.Status})`,
                        'DNSSEC Validated': data.AD ? 'Yes' : 'No',
                        'Answers Received': data.Answer?.length || 0
                    };
                } else {
                    return {
                        'DoH Query Time': 'Error',
                        'DoH Status': `HTTP ${response.status}`,
                        'DNSSEC Validated': 'N/A',
                        'Answers Received': 'N/A'
                    };
                }
            } catch (error) {
                return {
                    'DoH Query Time': error.name === 'AbortError' ? 'Timeout (>5s)' : 'Error',
                    'DoH Status': error.message || 'Failed',
                    'DNSSEC Validated': 'N/A',
                    'Answers Received': 'N/A'
                };
            }
        }


        // Test Google DNS performance and capabilities
        async function testGoogleDNS() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const startTime = performance.now();

                const response = await fetch(
                    'https://dns.google/resolve?name=cloudflare.com&type=A&do=1',
                    { signal: controller.signal }
                );

                clearTimeout(timeoutId);
                const endTime = performance.now();
                const queryTime = Math.round(endTime - startTime);

                if (response.ok) {
                    const data = await response.json();
                    return {
                        'Query Time': `${queryTime} ms`,
                        'Status': data.Status === 0 ? 'Success (NOERROR)' : `DNS Error ${data.Status}`,
                        'DNSSEC Validated': data.AD ? 'Yes' : 'No',
                        'Authoritative Server': data.Comment || 'Cached response',
                        'Answers Received': data.Answer?.length || 0,
                        'Note': 'Metadata limited (no data center/TLS info available)'
                    };
                } else {
                    return {
                        'Query Time': `${queryTime} ms`,
                        'Status': `HTTP ${response.status}`,
                        'Note': 'Request failed'
                    };
                }
            } catch (error) {
                return {
                    'Query Time': error.name === 'AbortError' ? 'Timeout (>5s)' : 'Error',
                    'Status': error.message || 'Failed',
                    'Note': 'Unable to reach Google DNS'
                };
            }
        }

        // Test AdGuard DNS performance and capabilities
        async function testAdGuardDNS() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const startTime = performance.now();

                const response = await fetch(
                    'https://dns.adguard-dns.com/dns-query?name=cloudflare.com&type=A&do=1',
                    {
                        headers: { 'Accept': 'application/dns-json' },
                        signal: controller.signal
                    }
                );

                clearTimeout(timeoutId);
                const endTime = performance.now();
                const queryTime = Math.round(endTime - startTime);

                if (response.ok) {
                    const data = await response.json();
                    return {
                        'Query Time': `${queryTime} ms`,
                        'Status': data.Status === 0 ? 'Success (NOERROR)' : `DNS Error ${data.Status}`,
                        'DNSSEC Validated': data.AD ? 'Yes' : 'No',
                        'Answers Received': data.Answer?.length || 0,
                        'Note': 'Privacy-focused DNS with ad/tracker blocking'
                    };
                } else {
                    return {
                        'Query Time': `${queryTime} ms`,
                        'Status': `HTTP ${response.status}`,
                        'DNSSEC Validated': 'N/A',
                        'Note': 'Request failed'
                    };
                }
            } catch (error) {
                return {
                    'Query Time': error.name === 'AbortError' ? 'Timeout (>5s)' : 'Error',
                    'Status': error.message || 'Failed',
                    'DNSSEC Validated': 'N/A',
                    'Note': 'Unable to reach AdGuard DNS'
                };
            }
        }

        // Detect DNS leaks via multi-resolver testing
        async function detectDNSLeaks() {
            const tests = [
                { name: 'Primary Resolver (Akamai)', query: 'whoami.ds.akahelp.net' },
                { name: 'Secondary Resolver (Google)', query: 'o-o.myaddr.l.google.com' },
                { name: 'IPv6 Resolver', query: 'whoami.ipv6.akahelp.net' }
            ];

            const results = {};
            const resolverIPs = [];

            for (const test of tests) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(
                        `https://dns.google/resolve?name=${test.query}&type=TXT`,
                        { signal: controller.signal }
                    );

                    clearTimeout(timeoutId);
                    const data = await response.json();

                    if (data.Status === 0 && data.Answer?.length > 0) {
                        // Parse TXT record (format: "ns: 1.2.3.4 ecs: 1.2.3.0/24")
                        const txtData = data.Answer[0].data.replace(/"/g, '');
                        const nsMatch = txtData.match(/ns:\s*([\d.:a-fA-F]+)/);

                        if (nsMatch) {
                            const resolverIP = nsMatch[1];
                            results[test.name] = resolverIP;
                            resolverIPs.push(resolverIP);

                            // Also extract ECS if present
                            const ecsMatch = txtData.match(/ecs:\s*([\d./a-fA-F:]+)/);
                            if (ecsMatch) {
                                results[`${test.name} (Client Subnet)`] = ecsMatch[1];
                            }
                        } else {
                            results[test.name] = 'Unable to parse';
                        }
                    } else if (test.name.includes('IPv6')) {
                        results[test.name] = 'No IPv6 DNS detected';
                    } else {
                        results[test.name] = 'No response';
                    }
                } catch (error) {
                    results[test.name] = error.name === 'AbortError' ? 'Timeout (>5s)' : 'Error';
                }
            }

            // Analyze results for leaks
            const validResolvers = resolverIPs.filter(ip => ip && !ip.includes('Error'));
            const uniqueResolvers = [...new Set(validResolvers)];

            if (uniqueResolvers.length === 0) {
                results['Analysis'] = 'Unable to determine (all tests failed)';
            } else if (uniqueResolvers.length === 1) {
                results['Analysis'] = 'No leak detected (consistent resolver across tests)';
                results['Your DNS Resolver'] = uniqueResolvers[0];
            } else {
                results['Analysis'] = `DNS Leak Detected (${uniqueResolvers.length} different resolvers)`;
                results['Resolvers Found'] = uniqueResolvers.join(', ');
            }

            return results;
        }

        // Update header with timestamp
        function updateTimestamp() {
            const now = new Date();
            let header = 'BROWSER & NETWORK DIAGNOSTIC REPORT\n';
            header += '='.repeat(60) + '\n';
            header += `Version: ${TOOL_VERSION}\n`;
            header += `Generated: ${now.toLocaleString()}\n`;
            document.getElementById('header').textContent = header;
        }

        // Create info section as plain text
        function createInfoSection(title, data) {
            let text = `\n${title}\n`;
            text += '-'.repeat(title.length) + '\n';
            for (const [key, value] of Object.entries(data)) {
                const plainValue = formatValue(value);
                text += `${key}: ${plainValue}\n`;
            }
            return text;
        }

        // Render all diagnostic information
        async function renderAllInfo() {
            // Collect synchronous data
            diagnosticData = {
                'Browser Information': getBrowserInfo(),
                'Screen & Display': getScreenInfo(),
                'Browser Capabilities': getCapabilities(),
                'Network Information': getNetworkInfo(),
                'Performance Metrics': getPerformanceInfo(),
                'Security Context': getSecurityInfo(),
                'Additional Details': getAdditionalDetails()
            };

            // Render initial data as plain text
            let text = '';
            for (const [section, data] of Object.entries(diagnosticData)) {
                text += createInfoSection(section, data);
            }
            document.getElementById('diagnosticContent').textContent = text;

            // Fetch all async data in parallel
            const [ipAddress, dnsInfo, dnsPerf, googleDNS, adguardDNS, dnsLeak] = await Promise.all([
                getIPAddress(),
                getDNSResolverInfo(),
                testDNSPerformance(),
                testGoogleDNS(),
                testAdGuardDNS(),
                detectDNSLeaks()
            ]);

            // Update Network Information with IP
            diagnosticData['Network Information']['Public IP Address'] = ipAddress;

            // Add DNS sections
            diagnosticData['DNS Resolver Connectivity'] = dnsInfo.results;
            diagnosticData['DNS Protocol & Encryption'] = detectDNSEncryption(dnsInfo.traceData, dnsInfo.results);
            diagnosticData['DNS Network Path'] = parseCloudflareTrace(dnsInfo.traceData);

            // Grouped DNS Benchmarks
            diagnosticData['DNS Provider Benchmark'] = {
                'Cloudflare (1.1.1.1)': `${dnsPerf['DoH Query Time']} (Status: ${dnsPerf['DoH Status']}, DNSSEC: ${dnsPerf['DNSSEC Validated']})`,
                'Google (8.8.8.8)': `${googleDNS['Query Time']} (Status: ${googleDNS['Status']}, DNSSEC: ${googleDNS['DNSSEC Validated']})`,
                'AdGuard DNS': `${adguardDNS['Query Time']} (Status: ${adguardDNS['Status']}, DNSSEC: ${adguardDNS['DNSSEC Validated']})`
            };

            // Add DNS Leak Detection
            diagnosticData['DNS Leak Detection'] = dnsLeak;

            // Re-render all sections with DNS data
            text = '';
            for (const [section, data] of Object.entries(diagnosticData)) {
                text += createInfoSection(section, data);
            }
            document.getElementById('diagnosticContent').textContent = text;

            updateTimestamp();
        }

        // Export data as JSON file
        function exportAsJSON() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const json = JSON.stringify(diagnosticData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `diagnostic-report-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Export data as CSV file
        function exportAsCSV() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            let csv = 'Section,Key,Value\n';

            for (const [section, data] of Object.entries(diagnosticData)) {
                for (const [key, value] of Object.entries(data)) {
                    const plainValue = formatValue(value);
                    // Escape quotes and wrap in quotes for CSV
                    const escapedValue = String(plainValue).replace(/"/g, '""');
                    csv += `"${section}","${key}","${escapedValue}"\n`;
                }
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `diagnostic-report-${timestamp}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Copy all data to clipboard
        async function copyToClipboard() {
            try {
                const header = document.getElementById('header').textContent;
                const content = document.getElementById('diagnosticContent').textContent;
                // Combine header and content, ensuring proper spacing
                const text = header + '\n' + content;

                await navigator.clipboard.writeText(text);
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.backgroundColor = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.backgroundColor = '';
                }, 2000);
            } catch (error) {
                alert('Failed to copy to clipboard. Please copy manually from the page.');
            }
        }

        // Refresh all data
        function refreshData() {
            document.getElementById('diagnosticContent').textContent = 'Refreshing diagnostic information...';
            setTimeout(() => renderAllInfo(), 100);
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            renderAllInfo();
        });

        // Update online/offline status dynamically
        window.addEventListener('online', () => {
            diagnosticData['Network Information']['Online Status'] = 'Online';
            refreshData();
        });

        window.addEventListener('offline', () => {
            diagnosticData['Network Information']['Online Status'] = 'Offline';
            refreshData();
        });
    </script>
</body>
</html>

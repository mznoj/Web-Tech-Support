<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Browser and Network Diagnostic Tool for debugging access issues">
    <title>Browser & Network Diagnostic Tool</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
        }

        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
        }

        @media print {
            button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <noscript>
        <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; padding: 15px; margin: 20px; color: #721c24;">
            <strong>JavaScript Required:</strong> This diagnostic tool requires JavaScript to be enabled in your browser. Please enable JavaScript and reload the page.
        </div>
    </noscript>

    <div style="max-width: 1000px; margin: 20px;">
        <pre id="header" style="font-family: monospace; line-height: 1.5;"></pre>
        <div style="margin: 10px 0;">
            <button onclick="copyToClipboard()" id="copyBtn">Copy All Data</button>
            <button onclick="refreshData()">Refresh</button>
        </div>
        <pre id="diagnosticContent" style="font-family: monospace; line-height: 1.5;">Loading...</pre>
    </div>

    <script>
        // Global data storage
        let diagnosticData = {};

        // Utility function to format values for plain text display
        function formatValue(value, type = 'default') {
            if (value === null || value === undefined) {
                return 'Not Available';
            }

            if (typeof value === 'boolean') {
                return value ? 'Enabled' : 'Disabled';
            }

            return value;
        }

        // Get browser information
        function getBrowserInfo() {
            try {
                const nav = navigator;
                const ua = nav.userAgent;

                // Parse browser name and version
                let browserName = 'Unknown';
                let browserVersion = 'Unknown';

                if (ua.indexOf('Firefox') > -1) {
                    browserName = 'Firefox';
                    browserVersion = ua.match(/Firefox\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (ua.indexOf('Edg') > -1) {
                    browserName = 'Edge';
                    browserVersion = ua.match(/Edg\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (ua.indexOf('Chrome') > -1) {
                    browserName = 'Chrome';
                    browserVersion = ua.match(/Chrome\/([0-9.]+)/)?.[1] || 'Unknown';
                } else if (ua.indexOf('Safari') > -1) {
                    browserName = 'Safari';
                    browserVersion = ua.match(/Version\/([0-9.]+)/)?.[1] || 'Unknown';
                }

                return {
                    'User Agent': ua,
                    'Browser': `${browserName} ${browserVersion}`,
                    'Platform': nav.platform || 'Unknown',
                    'OS': getOSInfo(),
                    'Language': nav.language || 'Unknown',
                    'Languages': nav.languages?.join(', ') || 'Unknown',
                    'Cookies Enabled': nav.cookieEnabled,
                    'Hardware Concurrency': nav.hardwareConcurrency || 'Not Available',
                    'Device Memory': nav.deviceMemory ? `${nav.deviceMemory} GB` : 'Not Available',
                    'Max Touch Points': nav.maxTouchPoints || 0,
                    'Vendor': nav.vendor || 'Unknown',
                    'Product': nav.product || 'Unknown'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get OS information from user agent
        function getOSInfo() {
            const ua = navigator.userAgent;
            if (ua.indexOf('Win') > -1) return 'Windows';
            if (ua.indexOf('Mac') > -1) return 'macOS';
            if (ua.indexOf('Linux') > -1) return 'Linux';
            if (ua.indexOf('Android') > -1) return 'Android';
            if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) return 'iOS';
            return 'Unknown';
        }

        // Get screen and display information
        function getScreenInfo() {
            try {
                return {
                    'Screen Resolution': `${screen.width} × ${screen.height}`,
                    'Available Screen': `${screen.availWidth} × ${screen.availHeight}`,
                    'Viewport Size': `${window.innerWidth} × ${window.innerHeight}`,
                    'Color Depth': `${screen.colorDepth}-bit`,
                    'Pixel Ratio': window.devicePixelRatio || 1,
                    'Orientation': screen.orientation?.type || window.orientation !== undefined ? `${window.orientation}°` : 'Not Available',
                    'Touch Support': navigator.maxTouchPoints > 0 || 'ontouchstart' in window
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get browser capabilities
        function getCapabilities() {
            try {
                const testLocalStorage = () => {
                    try {
                        localStorage.setItem('test', 'test');
                        localStorage.removeItem('test');
                        return true;
                    } catch (e) {
                        return false;
                    }
                };

                const testSessionStorage = () => {
                    try {
                        sessionStorage.setItem('test', 'test');
                        sessionStorage.removeItem('test');
                        return true;
                    } catch (e) {
                        return false;
                    }
                };

                return {
                    'JavaScript': true,
                    'Cookies': navigator.cookieEnabled,
                    'Local Storage': testLocalStorage(),
                    'Session Storage': testSessionStorage(),
                    'IndexedDB': 'indexedDB' in window,
                    'WebGL': (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                        } catch (e) {
                            return false;
                        }
                    })(),
                    'Service Worker': 'serviceWorker' in navigator,
                    'WebAssembly': typeof WebAssembly !== 'undefined',
                    'Geolocation': 'geolocation' in navigator,
                    'Notifications': 'Notification' in window,
                    'Web Workers': typeof Worker !== 'undefined',
                    'WebRTC': !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    'Canvas': (() => {
                        try {
                            const canvas = document.createElement('canvas');
                            return !!(canvas.getContext && canvas.getContext('2d'));
                        } catch (e) {
                            return false;
                        }
                    })()
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get network information
        function getNetworkInfo() {
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

                return {
                    'Online Status': navigator.onLine ? 'Online' : 'Offline',
                    'Connection Type': conn?.effectiveType || 'Not Available',
                    'Downlink': conn?.downlink ? `${conn.downlink} Mbps` : 'Not Available',
                    'RTT': conn?.rtt ? `${conn.rtt} ms` : 'Not Available',
                    'Save Data': conn?.saveData !== undefined ? conn.saveData : 'Not Available',
                    'Protocol': window.location.protocol,
                    'Hostname': window.location.hostname,
                    'Port': window.location.port || 'Default'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get performance metrics
        function getPerformanceInfo() {
            try {
                if (!window.performance || !window.performance.timing) {
                    return { 'Performance API': 'Not Available' };
                }

                const timing = performance.timing;
                const navigation = performance.navigation;

                const pageLoadTime = timing.loadEventEnd - timing.navigationStart;
                const dnsTime = timing.domainLookupEnd - timing.domainLookupStart;
                const tcpTime = timing.connectEnd - timing.connectStart;
                const tlsTime = timing.secureConnectionStart > 0 ? timing.connectEnd - timing.secureConnectionStart : 'N/A (HTTP)';
                const ttfb = timing.responseStart - timing.navigationStart;
                const domLoad = timing.domContentLoadedEventEnd - timing.navigationStart;

                return {
                    'Page Load Time': pageLoadTime > 0 ? `${pageLoadTime} ms` : 'Calculating...',
                    'DNS Lookup': dnsTime >= 0 ? `${dnsTime} ms` : 'Not Available',
                    'TCP Connection': tcpTime >= 0 ? `${tcpTime} ms` : 'Not Available',
                    'TLS Negotiation': typeof tlsTime === 'number' ? `${tlsTime} ms` : tlsTime,
                    'Time to First Byte': ttfb > 0 ? `${ttfb} ms` : 'Not Available',
                    'DOM Load': domLoad > 0 ? `${domLoad} ms` : 'Calculating...',
                    'Navigation Type': navigation ? ['Navigate', 'Reload', 'Back/Forward'][navigation.type] || 'Unknown' : 'Not Available',
                    'Redirect Count': navigation?.redirectCount || 0
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get security context information
        function getSecurityInfo() {
            try {
                return {
                    'Protocol': window.location.protocol,
                    'Secure Context': window.isSecureContext,
                    'Cross-Origin Isolated': window.crossOriginIsolated || false,
                    'Referrer Policy': document.referrerPolicy || 'Not Set',
                    'Document Domain': document.domain,
                    'Mixed Content': window.location.protocol === 'https:' && document.querySelector('script[src^="http:"], img[src^="http:"], link[href^="http:"]') ? 'Detected' : 'None'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get additional details
        function getAdditionalDetails() {
            try {
                return {
                    'Current URL': window.location.href,
                    'Referrer': document.referrer || 'Direct/No Referrer',
                    'Document Mode': document.compatMode,
                    'Character Encoding': document.characterSet || document.charset,
                    'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                    'Timezone Offset': `UTC${new Date().getTimezoneOffset() > 0 ? '-' : '+'}${Math.abs(new Date().getTimezoneOffset() / 60)}`,
                    'Screen Orientation API': screen.orientation ? 'Supported' : 'Not Supported',
                    'Battery API': 'getBattery' in navigator ? 'Supported' : 'Not Supported'
                };
            } catch (error) {
                return { 'Error': error.message };
            }
        }

        // Get IP address from external API
        async function getIPAddress() {
            try {
                const response = await fetch('https://api.ipify.org?format=json', { timeout: 5000 });
                const data = await response.json();
                return data.ip;
            } catch (error) {
                return 'Unable to fetch (blocked or offline)';
            }
        }

        // Get DNS resolver connectivity information
        async function getDNSResolverInfo() {
            const resolvers = [
                { name: '1.1.1.1 (IPv4)', url: 'https://1.1.1.1/cdn-cgi/trace' },
                { name: '1.0.0.1 (IPv4)', url: 'https://1.0.0.1/cdn-cgi/trace' },
                { name: '2606:4700:4700::1111 (IPv6)', url: 'https://[2606:4700:4700::1111]/cdn-cgi/trace' },
                { name: '2606:4700:4700::1001 (IPv6)', url: 'https://[2606:4700:4700::1001]/cdn-cgi/trace' }
            ];

            const results = {};
            const promises = resolvers.map(async (resolver) => {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    const response = await fetch(resolver.url, { signal: controller.signal });
                    clearTimeout(timeoutId);

                    if (response.ok) {
                        results[resolver.name] = 'Connected';
                        return response.text();
                    } else {
                        results[resolver.name] = `Error ${response.status}`;
                        return null;
                    }
                } catch (error) {
                    results[resolver.name] = error.name === 'AbortError' ? 'Timeout' : 'Not Connected';
                    return null;
                }
            });

            const traces = await Promise.all(promises);
            return { results, traceData: traces.find(t => t !== null) };
        }

        // Parse Cloudflare trace data
        function parseCloudflareTrace(traceText) {
            if (!traceText) return {};

            const data = {};
            traceText.split('\n').forEach(line => {
                const [key, value] = line.split('=');
                if (key && value) data[key.trim()] = value.trim();
            });

            return {
                'Data Center Location': data.colo || 'Unknown',
                'TLS Version': data.tls || 'Unknown',
                'HTTP Version': data.http || 'Unknown',
                'WARP Status': data.warp === 'on' ? 'Active' : 'Not Active',
                'Gateway Status': data.gateway === 'on' ? 'Active' : 'Not Active'
            };
        }

        // Detect DNS encryption status
        function detectDNSEncryption(traceText, connectivityResults) {
            const trace = {};
            if (traceText) {
                traceText.split('\n').forEach(line => {
                    const [key, value] = line.split('=');
                    if (key && value) trace[key.trim()] = value.trim();
                });
            }

            const warpActive = trace.warp === 'on';
            const gatewayActive = trace.gateway === 'on';
            const cloudflareConnected = connectivityResults['1.1.1.1 (IPv4)'] === 'Connected';

            let dohStatus = 'Unknown';
            if (warpActive) {
                dohStatus = 'Using DNS-over-WARP';
            } else if (gatewayActive) {
                dohStatus = 'Using Cloudflare Gateway';
            } else if (cloudflareConnected) {
                dohStatus = 'Likely Using DoH (inferred)';
            } else {
                dohStatus = 'Not Detected';
            }

            return {
                'DNS-over-HTTPS (DoH)': dohStatus,
                'DNS-over-TLS (DoT)': 'Not Detectable in Browser',
                'DNS-over-WARP': warpActive ? 'Active' : 'Not Active'
            };
        }

        // Test DNS performance using DoH
        async function testDNSPerformance() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const startTime = performance.now();

                const response = await fetch(
                    'https://cloudflare-dns.com/dns-query?name=cloudflare.com&type=A',
                    {
                        headers: { 'Accept': 'application/dns-json' },
                        signal: controller.signal
                    }
                );

                clearTimeout(timeoutId);
                const endTime = performance.now();
                const queryTime = Math.round(endTime - startTime);

                if (response.ok) {
                    const data = await response.json();
                    return {
                        'DoH Query Time': `${queryTime} ms`,
                        'DoH Status': data.Status === 0 ? 'Working' : `Error (Status ${data.Status})`,
                        'Answers Received': data.Answer?.length || 0
                    };
                } else {
                    return {
                        'DoH Query Time': 'Error',
                        'DoH Status': `HTTP ${response.status}`,
                        'Answers Received': 'N/A'
                    };
                }
            } catch (error) {
                return {
                    'DoH Query Time': error.name === 'AbortError' ? 'Timeout (>5s)' : 'Error',
                    'DoH Status': error.message || 'Failed',
                    'Answers Received': 'N/A'
                };
            }
        }

        // Update header with timestamp
        function updateTimestamp() {
            const now = new Date();
            let header = 'BROWSER & NETWORK DIAGNOSTIC REPORT\n';
            header += '='.repeat(60) + '\n';
            header += `Generated: ${now.toLocaleString()}\n`;
            document.getElementById('header').textContent = header;
        }

        // Create info section as plain text
        function createInfoSection(title, data) {
            let text = `\n${title}\n`;
            text += '-'.repeat(title.length) + '\n';
            for (const [key, value] of Object.entries(data)) {
                const plainValue = formatValue(value);
                text += `${key}: ${plainValue}\n`;
            }
            return text;
        }

        // Render all diagnostic information
        async function renderAllInfo() {
            // Collect synchronous data
            diagnosticData = {
                'Browser Information': getBrowserInfo(),
                'Screen & Display': getScreenInfo(),
                'Browser Capabilities': getCapabilities(),
                'Network Information': getNetworkInfo(),
                'Performance Metrics': getPerformanceInfo(),
                'Security Context': getSecurityInfo(),
                'Additional Details': getAdditionalDetails()
            };

            // Render initial data as plain text
            let text = '';
            for (const [section, data] of Object.entries(diagnosticData)) {
                text += createInfoSection(section, data);
            }
            document.getElementById('diagnosticContent').textContent = text;

            // Fetch all async data in parallel
            const [ipAddress, dnsInfo, dnsPerf] = await Promise.all([
                getIPAddress(),
                getDNSResolverInfo(),
                testDNSPerformance()
            ]);

            // Update Network Information with IP
            diagnosticData['Network Information']['Public IP Address'] = ipAddress;

            // Add DNS sections
            diagnosticData['DNS Resolver Connectivity'] = dnsInfo.results;
            diagnosticData['DNS Protocol & Encryption'] = detectDNSEncryption(dnsInfo.traceData, dnsInfo.results);
            diagnosticData['DNS Network Path'] = parseCloudflareTrace(dnsInfo.traceData);
            diagnosticData['DNS Performance'] = dnsPerf;

            // Re-render all sections with DNS data
            text = '';
            for (const [section, data] of Object.entries(diagnosticData)) {
                text += createInfoSection(section, data);
            }
            document.getElementById('diagnosticContent').textContent = text;

            updateTimestamp();
        }

        // Copy all data to clipboard
        async function copyToClipboard() {
            let text = 'BROWSER & NETWORK DIAGNOSTIC REPORT\n';
            text += '=' .repeat(60) + '\n';
            text += `Generated: ${new Date().toLocaleString()}\n\n`;

            for (const [section, data] of Object.entries(diagnosticData)) {
                text += `\n${section}\n`;
                text += '-'.repeat(section.length) + '\n';
                for (const [key, value] of Object.entries(data)) {
                    // Strip HTML for plain text
                    const plainValue = typeof value === 'boolean'
                        ? (value ? 'Enabled' : 'Disabled')
                        : (value === null || value === undefined ? 'Not Available' : value);
                    text += `${key}: ${plainValue}\n`;
                }
            }

            try {
                await navigator.clipboard.writeText(text);
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.backgroundColor = '#28a745';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.backgroundColor = '';
                }, 2000);
            } catch (error) {
                alert('Failed to copy to clipboard. Please copy manually from the page.');
            }
        }

        // Refresh all data
        function refreshData() {
            document.getElementById('diagnosticContent').textContent = 'Refreshing diagnostic information...';
            setTimeout(() => renderAllInfo(), 100);
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            renderAllInfo();
        });

        // Update online/offline status dynamically
        window.addEventListener('online', () => {
            diagnosticData['Network Information']['Online Status'] = 'Online';
            refreshData();
        });

        window.addEventListener('offline', () => {
            diagnosticData['Network Information']['Online Status'] = 'Offline';
            refreshData();
        });
    </script>
</body>
</html>
